import pyguy as pg

class MyGame(pg.PG):
    def initialize(self):
        self.x = 100
        self.y = 300
        self.speed = 200  # pixels per second

    def update(self, dt):
        # Move the circle to the right
        self.x += self.speed * dt
        if self.x > 800:  # wrap around
            self.x = 0

    def render(self, dt):
        self._PG__canvas.create_oval(
            self.x - 50, self.y - 50,
            self.x + 50, self.y + 50,
            fill="yellow"
        )

game = MyGame(800, 600, "Moving Circle")
import tkinter as tk

class PG:
    def __init__(self, width=800, height=600, title="Tkinter Window", fps=60):
        self.__width = width
        self.__height = height
        self.__fps = fps

        self.__root = tk.Tk()
        self.__root.title(title)

        self.__canvas = tk.Canvas(self.__root, width=self.__width, height=self.__height, bg="black")
        self.__canvas.pack()

        self.initialize()

        self.__loop()
        self.__root.mainloop()

    def __loop(self):
        self.update(1/self.__fps)
        self.__canvas.delete("all")
        self.render(1/self.__fps)
        self.__root.after(int(1000 / self.__fps), self.__loop)

    def initialize(self):
        pass

    def update(self, dt):
        pass

    def render(self, dt):
        pass
import random


def colored_text(text, color):
    """Returns colored text with the selected color variable."""

    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    GREY = '\033[37m'
    RESET = '\033[0m'

    if color == "black":
        data = BLACK
    elif color == "red":
        data = RED
    elif color == "green":
        data = GREEN
    elif color == "yellow":
        data = YELLOW
    elif color == "blue":
        data = BLUE
    elif color == "magenta":
        data = MAGENTA
    elif color == "cyan":
        data = CYAN
    elif color == "grey":
        data = GREY
    else:
        data = None

    if data is None:
        return text
    else:
        return data + text + RESET


class X:
    def __str__(self):
        return colored_text("X", "red")


class O:
    def __str__(self):
        return colored_text("O", "blue")


class Blank:
    def __init__(self, position):
        self.position = position

    def __str__(self):
        return colored_text(str(self.position), "yellow")


class Board:
    def __init__(self):
        self.slots = [Blank(0), Blank(1), Blank(2), Blank(3), Blank(4), Blank(5), Blank(6), Blank(7), Blank(8)]

    def set(self, slot, type):
        self.slots[slot] = type

    def get(self, slot):
        return self.slots[slot]

    def contains_win(self):
        def convert(slot, current):
            if isinstance(slot, current):
                return "1"
            else:
                return "0"

        combinations = open("wincombonations.txt", "r").read()

        # Test X
        comb = convert(self.slots[0], X) + convert(self.slots[1], X) + convert(self.slots[2], X) + convert(
            self.slots[3], X) + convert(self.slots[4], X) + convert(self.slots[5], X) + convert(self.slots[6],
                                                                                                X) + convert(
            self.slots[7], X) + convert(self.slots[8], X)
        if comb in combinations.split("\n"):
            return "X"

        # Test O
        comb = convert(self.slots[0], O) + convert(self.slots[1], O) + convert(self.slots[2], O) + convert(
            self.slots[3], O) + convert(self.slots[4], O) + convert(self.slots[5], O) + convert(self.slots[6],
                                                                                                O) + convert(
            self.slots[7], O) + convert(self.slots[8], O)
        if comb in combinations.split("\n"):
            return "O"


        return " "

    def display(self):
        return f"{self.slots[0]} | {self.slots[1]} | {self.slots[2]}\n---------\n{self.slots[3]} | {self.slots[4]} | {self.slots[5]}\n---------\n{self.slots[6]} | {self.slots[7]} | {self.slots[8]}"

    def position_valid(self, position):
        if len(position) == 1:
            if position in list("012345678"):
                if isinstance(self.slots[int(position)], Blank):
                    return True
        return False


def main():
    print("\n\n")
    board = Board()
    turn = random.choice([X(), O()])

    running = True
    while running:
        print("\n\n\n\n\n\n\n\n")
        print(board.display() + "\n")

        # TODO Fix the inputted position bug
        entered_position = input(f"Player {turn} - choose a position ({colored_text("0-8", "yellow")}):\n>>>")
        if not board.position_valid(entered_position):
            print("\n\n\n\n\n\n\n\n")
            print("Invalid position!")
            print(board.display() + "\n")

            entered_position = input(f"Player {turn} - choose a position ({colored_text("0-8", "yellow")}):\n>>>")

        board.set(int(entered_position), turn)

        winner = board.contains_win()
        if winner != " ":
            if winner == "X":
                # X winner
                print(f"Player {colored_text("X", "red")} is the winner!")
            else:
                # O winner
                print(f"Player {colored_text("O", "blue")} is the winner!")

            running = False

        if isinstance(turn, X):
            turn = O()
        else:
            turn = X()


if __name__ == '__main__':
    main()
from PIL import Image
import re

def are_vertices_in_face(vert_1, vert_2, face_p1, face_p2, face_p3):
    return (vert_1 in (face_p1, face_p2, face_p3)) and (vert_2 in (face_p1, face_p2, face_p3))

def process(obj_directory, properties_directory):
    print("processing started")
    print("getting obj, mtl, and properties data")

    # Get obj data
    obj_data = open(obj_directory, "r").read()

    # Get mtl data
    for line in obj_data.split("\n"):
        if line.startswith("mtllib "):
            mtl_directory = line.removeprefix("mtllib ")
            mtl_data = open(mtl_directory, "r").read()
            break

    # Get properties data
    properties_data = open(properties_directory, "r").read()

    # Parse properties data
    print("parsing properties data")

    properties = {}

    for line in properties_data.split("\n"):
        if line.endswith(":"):
            current_object_id = line.removesuffix(":")
            properties[current_object_id] = {}
            properties[current_object_id]["name"] = current_object_id
        elif line.startswith("    ") and line != "    ":
            properties[current_object_id][line.removeprefix("    ").split(": ")[0]] = line.removeprefix("    ").split(": ")[1]
        else:
            pass

    # Reset output variables
    print("resetting output variables")

    vert_x = []
    vert_y = []
    vert_z = []

    temp_u = []
    temp_v = []

    static_p1 = []
    static_p2 = []
    static_p3 = []
    static_u1 = []
    static_v1 = []
    static_u2 = []
    static_v2 = []
    static_u3 = []
    static_v3 = []
    static_texture_id = []
    static_bound = []

    active_p1 = []
    active_p2 = []
    active_p3 = []
    active_u1 = []
    active_v1 = []
    active_u2 = []
    active_v2 = []
    active_u3 = []
    active_v3 = []
    active_texture_id = []
    active_bound = []
    active_offset_x = []
    active_offset_y = []
    active_offset_z = []
    active_required = []
    active_ticks = []
    active_interpolation = []
    active_sound = []
    active_camera_lock = []

    floor_x = []
    floor_y = []
    floor_z = []
    floor_p1 = []
    floor_p2 = []
    floor_p3 = []
    floor_x1 = []
    floor_y1 = []
    floor_x2 = []
    floor_y2 = []

    marker_name = []
    marker_type = []
    marker_x = []
    marker_y = []
    marker_z = []
    marker_text = []
    marker_locked_text = []
    marker_sound = []
    marker_required = []
    marker_document = []
    marker_tpx = []
    marker_tpy = []
    marker_tpz = []

    sound_x = []
    sound_y = []
    sound_z = []
    sound_sound = []
    sound_range = []
    sound_volume = []

    bound_name = []
    bound_x1 = []
    bound_y1 = []
    bound_z1 = []
    bound_x2 = []
    bound_y2 = []
    bound_z2 = []
    bound_x = []
    bound_y = []
    bound_z = []

    # Read obj
    print("reading obj data")

    for line in obj_data.split("\n"):
        if line.startswith("o "):
            current_object_id = line.removesuffix("o ")
            current_object_properties = properties[current_object_id.removeprefix("o ")]
            current_object_type = current_object_properties["type"]
            if current_object_type == "bound":
                bound_name.append(current_object_properties["name"])
                bound_x1.append(0)
                bound_y1.append(0)
                bound_z1.append(0)
                bound_x2.append(0)
                bound_y2.append(0)
                bound_z2.append(0)
                bound_x.append([])
                bound_y.append([])
                bound_z.append([])
        elif line.startswith("v "):
            if current_object_type == "marker":
                marker_name.append(current_object_properties["name"])
                marker_type.append(current_object_properties["marker_type"])
                marker_x.append(line.removeprefix("v ").split(" ")[0])
                marker_y.append(line.removeprefix("v ").split(" ")[1])
                marker_z.append(0 - float(line.removeprefix("v ").split(" ")[2]))
                marker_text.append(current_object_properties["text"])
                marker_locked_text.append(current_object_properties["locked_text"])
                marker_required.append(current_object_properties["required"])

                if current_object_properties["marker_type"] == "active":
                    marker_sound.append(current_object_properties["sound"])
                else:
                    marker_sound.append("none")

                if current_object_properties["marker_type"] == "teleport":
                    marker_tpx.append(current_object_properties["tpx"])
                    marker_tpy.append(current_object_properties["tpz"])
                    marker_tpz.append(current_object_properties["tpy"])
                else:
                    marker_tpx.append(0)
                    marker_tpy.append(0)
                    marker_tpz.append(0)

                if current_object_properties["marker_type"] == "document":
                    marker_document.append(current_object_properties["document"])
                else:
                    marker_document.append(0)

            elif current_object_type == "sound":
                sound_x.append(line.removeprefix("v ").split(" ")[0])
                sound_y.append(line.removeprefix("v ").split(" ")[1])
                sound_z.append(0 - float(line.removeprefix("v ").split(" ")[2]))
                sound_sound.append(current_object_properties["sound"])
                sound_range.append(current_object_properties["range"])
                sound_volume.append(current_object_properties["volume"])

            elif current_object_type == "bound":
                ind = bound_name.index(current_object_properties["name"])
                bound_x[ind].append(line.removeprefix("v ").split(" ")[0])
                bound_y[ind].append(line.removeprefix("v ").split(" ")[1])
                bound_z[ind].append(0 - float(line.removeprefix("v ").split(" ")[2]))
            else:
                pass

            vert_x.append(line.removeprefix("v ").split(" ")[0])
            vert_y.append(line.removeprefix("v ").split(" ")[1])
            vert_z.append(0 - float(line.removeprefix("v ").split(" ")[2]))
        elif line.startswith("vt "):
            temp_u.append(float(line.removeprefix("vt ").split(" ")[0]))
            temp_v.append(1 - float(line.removeprefix("vt ").split(" ")[1]))
        elif line.startswith("f "):
            if current_object_type == "static":
                face_data = line.removeprefix("f ").split(" ")
                p1 = face_data[0].split("/")
                p2 = face_data[1].split("/")
                p3 = face_data[2].split("/")
                static_p1.append(p1[0])
                static_p2.append(p2[0])
                static_p3.append(p3[0])
                static_u1.append(temp_u[int(p1[1]) - 1])
                static_v1.append(temp_v[int(p1[1]) - 1])
                static_u2.append(temp_u[int(p2[1]) - 1])
                static_v2.append(temp_v[int(p2[1]) - 1])
                static_u3.append(temp_u[int(p3[1]) - 1])
                static_v3.append(temp_v[int(p3[1]) - 1])
                static_texture_id.append(current_texture_id)
                static_bound.append(current_object_properties["bound"])
            elif current_object_type == "active":
                face_data = line.removeprefix("f ").split(" ")
                p1 = face_data[0].split("/")
                p2 = face_data[1].split("/")
                p3 = face_data[2].split("/")
                active_p1.append(p1[0])
                active_p2.append(p2[0])
                active_p3.append(p3[0])
                active_u1.append(temp_u[int(p1[1]) - 1])
                active_v1.append(temp_v[int(p1[1]) - 1])
                active_u2.append(temp_u[int(p2[1]) - 1])
                active_v2.append(temp_v[int(p2[1]) - 1])
                active_u3.append(temp_u[int(p3[1]) - 1])
                active_v3.append(temp_v[int(p3[1]) - 1])
                active_texture_id.append(current_texture_id)
                active_bound.append(current_object_properties["bound"])
                active_offset_x.append(current_object_properties["x_offset"])
                active_offset_y.append(current_object_properties["z_offset"])
                active_offset_z.append(current_object_properties["y_offset"])
                active_ticks.append(current_object_properties["ticks"])
                active_interpolation.append(current_object_properties["interpolation"])
                active_sound.append(current_object_properties["sound"])
                active_required.append(str(current_object_properties["required"]).replace(", ", "/"))
                active_camera_lock.append(current_object_properties["camera_lock"])
            elif current_object_type == "floor":
                face_data = line.removeprefix("f ").split(" ")
                p1 = face_data[0].split("/")
                p2 = face_data[1].split("/")
                p3 = face_data[2].split("/")
                floor_p1.append(p1[0])
                floor_p2.append(p2[0])
                floor_p3.append(p3[0])
            else:
                pass
        elif line.startswith("usemtl "):
            current_texture_id = line.removeprefix("usemtl ")
        else:
            pass

    # Get min and max bound values
    print("calculating min and max bound values")

    for i in range(len(bound_name)):
        bound_x1[i] = min(bound_x[i])
        bound_y1[i] = min(bound_y[i])
        bound_z1[i] = min(bound_z[i])
        bound_x2[i] = max(bound_x[i])
        bound_y2[i] = max(bound_y[i])
        bound_z2[i] = max(bound_z[i])

    # Process collision line segments
    print(f"generating collision line segments: {len(vert_x) * len(vert_x) * len(floor_p1)} processes needed")

    for i in range(len(vert_x)):
        for j in range(len(vert_x)):
            face_count = 0
            for k in range(len(floor_p1)):
                if are_vertices_in_face(str(i + 1), str(j + 1), str(floor_p1[k]), str(floor_p2[k]), str(floor_p3[k])):
                    face_count = face_count + 1
            if face_count == 1:
                floor_x1.append(vert_x[i])
                floor_y1.append(vert_z[i])
                floor_x2.append(vert_x[j])
                floor_y2.append(vert_z[j])

    # Assemble final output
    print("assembling final output")

    global output
    output = ""

    def add(text):
        global output
        output = output + text + "\n"

    for i in range(len(vert_x)):
        add(f"v,{vert_x[i]},{vert_y[i]},{vert_z[i]}")

    for i in range(len(static_texture_id)):
        add(f"s,{static_p1[i]},{static_p2[i]},{static_p3[i]},{static_u1[i]},{static_v1[i]},{static_u2[i]},{static_v2[i]},{static_u3[i]},{static_v3[i]},{static_texture_id[i]},{static_bound[i]}")

    for i in range(len(active_texture_id)):
        add(f"a,{active_p1[i]},{active_p2[i]},{active_p3[i]},{active_u1[i]},{active_v1[i]},{active_u2[i]},{active_v2[i]},{active_u3[i]},{active_v3[i]},{active_texture_id[i]},{active_bound[i]},{active_offset_x[i]},{active_offset_y[i]},{active_offset_z[i]},{active_ticks[i]},{active_interpolation[i]},{active_sound[i]},{active_required[i]},{active_camera_lock[i]}")

    for i in range(len(floor_x1)):
        add(f"c,{floor_x1[i]},{floor_y1[i]},{floor_x2[i]},{floor_y2[i]}")

    for i in range(len(marker_text)):
        add(f"m,{marker_name[i]},{marker_type[i]},{marker_x[i]},{marker_y[i]},{marker_z[i]},{marker_text[i]},{marker_locked_text[i]},{marker_sound[i]},{marker_required[i]},{marker_document[i]},{marker_tpx[i]},{marker_tpy[i]},{marker_tpz[i]}")

    for i in range(len(bound_name)):
        add(f"b,{bound_name[i]},{bound_x1[i]},{bound_y1[i]},{bound_z1[i]},{bound_x2[i]},{bound_y2[i]},{bound_z2[i]}")

    for i in range(len(floor_p1)):
        add(f"f,{floor_p1[i]},{floor_p2[i]},{floor_p3[i]}")

    for i in range(len(sound_sound)):
        add(f"so,{sound_sound[i]},{sound_range[i]},{sound_volume[i]},{sound_x[i]},{sound_y[i]},{sound_z[i]}")

    output = output.removesuffix("\n")

    print("done processing")

    return output


obj_directory = "world.obj"
properties_directory = "properties.txt"

output_directory = "output.txt"

open(output_directory, "w").write(process(obj_directory, properties_directory))
from PIL import Image
import re


def find_text_after(search_string: str, text: str) -> str:
    pattern = re.escape(search_string) + r"(.*?)\n"
    match = re.search(pattern, text)
    return match.group(1) if match else None


def remove_lines_starting_with(prefix: str, text: str) -> str:
    pattern = rf"^{re.escape(prefix)}.*\n"
    return re.sub(pattern, "", text, flags=re.MULTILINE)


def remove_blank_lines(text: str) -> str:
    return "\n".join(line for line in text.splitlines() if line.strip())


def get_image_dimensions(path):
    with Image.open(path) as img:
        width, height = img.size

    return width, height


def get_image_pixel(path, x, y):
    with Image.open(path) as img:
        img = img.convert("RGB")

        rgb = img.getpixel((x, y))

        return rgb


def are_vertices_in_face(vert_1, vert_2, face_p1, face_p2, face_p3):
    return (vert_1 in (face_p1, face_p2, face_p3)) and (vert_2 in (face_p1, face_p2, face_p3))


def image_to_list(image_path):
    image_width, image_height = get_image_dimensions(image_path)

    image_x = 0
    image_y = 0

    pixels = []

    for image_y in range(image_height):
        for image_x in range(image_width):
            r, g, b = get_image_pixel(image_path, image_x, image_y)
            pixels.append(r * 65536 + g * 256 + b * 1)
            print(str(round(((image_x + image_y * image_height) / (image_width * image_height)) * 100, 2)) + "%")
            image_x += 1
        image_y += 1

    return pixels


def process(obj_data, mtl_data):
    obj_data = remove_lines_starting_with("#", obj_data)
    obj_data = remove_lines_starting_with("mtllib ", obj_data)
    obj_data = remove_blank_lines(obj_data)

    mtl_data = remove_lines_starting_with("#", mtl_data)
    mtl_data = remove_lines_starting_with("Ns ", mtl_data)
    mtl_data = remove_lines_starting_with("Ka ", mtl_data)
    mtl_data = remove_lines_starting_with("Ks ", mtl_data)
    mtl_data = remove_lines_starting_with("Ke ", mtl_data)
    mtl_data = remove_lines_starting_with("Ni ", mtl_data)
    mtl_data = remove_lines_starting_with("d ", mtl_data)
    mtl_data = remove_lines_starting_with("illum ", mtl_data)
    mtl_data = remove_blank_lines(mtl_data)

    vert_x = []
    vert_y = []
    vert_z = []

    temp_u = []
    temp_v = []

    static_p1 = []
    static_p2 = []
    static_p3 = []
    static_texture_id = []
    static_u1 = []
    static_v1 = []
    static_u2 = []
    static_v2 = []
    static_u3 = []
    static_v3 = []
    static_bound = []

    active_p1 = []
    active_p2 = []
    active_p3 = []
    active_texture_id = []
    active_u1 = []
    active_v1 = []
    active_u2 = []
    active_v2 = []
    active_u3 = []
    active_v3 = []
    active_offset_x = []
    active_offset_y = []
    active_offset_z = []
    active_required = []
    active_ticks = []
    active_interpolation = []
    active_sound = []

    floor_x = []
    floor_y = []
    floor_z = []
    floor_p1 = []
    floor_p2 = []
    floor_p3 = []
    floor_x1 = []
    floor_y1 = []
    floor_x2 = []
    floor_y2 = []

    marker_name = []
    marker_x = []
    marker_y = []
    marker_z = []
    marker_text = []
    marker_locked_text = []
    marker_sound = []
    marker_required = []

    bound_name = []
    bound_x1 = []
    bound_y1 = []
    bound_z1 = []
    bound_x2 = []
    bound_y2 = []
    bound_z2 = []

    texture_id = []
    texture_data = []
    texture_width = []
    texture_height = []
    texture_type = []

    materials = mtl_data.split("newmtl ")
    del materials[0]

    for material in materials:
        lines = material.split("\n")

        name = lines[0]
        texture = lines[1]
        if texture.startswith("Kd "):
            type = "color"
        else:
            type = "texture"

        if texture.startswith("Kd "):
            texture = texture.removeprefix("Kd ")

            r, g, b = texture.split(" ")

            data = str(int(float(float(r) * 255) * 65536 + float(float(g) * 255) * 256 + float(float(b) * 255) * 1))
            width = 1
            height = 1

        elif texture.startswith("map_Kd "):
            texture = texture.removeprefix("map_Kd ")

            processed = image_to_list(texture)

            data = ""

            for i in processed:
                data = data + str(i) + " "

            data = data.removesuffix(" ")

            width, height = get_image_dimensions(texture)

        else:
            quit("No texture directory or RGB value found.")
            data = ""

        texture_id.append(name)
        texture_data.append(data)
        texture_width.append(width)
        texture_height.append(height)
        texture_type.append(type)

    objects = obj_data.split("o ")
    del objects[0]

    for current_object in objects:
        lines = current_object.split("\n")
        object_name = lines[0].split(",")

        if object_name[1] == "floor":
            for line in lines:
                if line.startswith("v "):
                    line = line.removeprefix("v ")
                    line = line.split(" ")

                    x = str(float(line[0]) * 1)
                    y = str(float(line[1]) * 1)
                    z = str(float(line[2]) * -1)

                    vert_x.append(x)
                    vert_y.append(y)
                    vert_z.append(z)

                    floor_x.append(x)
                    floor_y.append(z)
                    floor_z.append(y)

                elif line.startswith("vt "):
                    line = line.removeprefix("vt ")
                    line = line.split(" ")

                    u = line[0]
                    v = str(float(line[1]) * -1)

                    temp_u.append(u)
                    temp_v.append(v)

                elif line.startswith("f "):
                    line = line.removeprefix("f ")
                    line = line.split(" ")

                    p1 = line[0].split("/")[0]
                    p2 = line[1].split("/")[0]
                    p3 = line[2].split("/")[0]

                    floor_p1.append(p1)
                    floor_p2.append(p2)
                    floor_p3.append(p3)

                else:
                    pass
        elif object_name[1] == "static":
            current_texture = "*no-texture*"

            for line in lines:
                if line.startswith("v "):
                    line = line.removeprefix("v ")
                    line = line.split(" ")

                    x = str(float(line[0]) * 1)
                    y = str(float(line[1]) * 1)
                    z = str(float(line[2]) * -1)

                    vert_x.append(x)
                    vert_y.append(y)
                    vert_z.append(z)

                    floor_x.append(x)
                    floor_y.append(z)
                    floor_z.append(y)

                elif line.startswith("vn "):
                    pass

                elif line.startswith("vt "):
                    line = line.removeprefix("vt ")
                    line = line.split(" ")

                    u = line[0]
                    v = str(float(line[1]) * -1)

                    temp_u.append(u)
                    temp_v.append(v)

                elif line.startswith("s "):
                    pass

                elif line.startswith("usemtl "):
                    current_texture = line.removeprefix("usemtl ")

                elif line.startswith("f "):
                    line = line.removeprefix("f ")
                    line = line.split(" ")

                    p1 = line[0].split("/")[0]
                    p2 = line[1].split("/")[0]
                    p3 = line[2].split("/")[0]
                    pt1 = line[0].split("/")[1]
                    pt2 = line[1].split("/")[1]
                    pt3 = line[2].split("/")[1]
                    pn1 = line[0].split("/")[2]
                    pn2 = line[1].split("/")[2]
                    pn3 = line[2].split("/")[2]

                    static_p1.append(p1)
                    static_p2.append(p2)
                    static_p3.append(p3)

                    if current_texture == "*no-texture*":
                        static_u1.append(0)
                        static_v1.append(0)
                        static_u2.append(0)
                        static_v2.append(1)
                        static_u3.append(1)
                        static_v3.append(1)
                        static_texture_id.append("*no-texture*")

                    elif texture_type[texture_id.index(current_texture)] == "texture":
                        static_u1.append(float(temp_u[int(pt1) - 1]))
                        static_v1.append(1 - (0 - float(temp_v[int(pt1) - 1])))
                        static_u2.append(float(temp_u[int(pt2) - 1]))
                        static_v2.append(1 - (0 - float(temp_v[int(pt2) - 1])))
                        static_u3.append(float(temp_u[int(pt3) - 1]))
                        static_v3.append(1 - (0 - float(temp_v[int(pt3) - 1])))
                        static_texture_id.append(current_texture)

                    else:
                        static_u1.append(0)
                        static_v1.append(0)
                        static_u2.append(0)
                        static_v2.append(1)
                        static_u3.append(1)
                        static_v3.append(1)
                        static_texture_id.append(current_texture)

                    static_bound.append(object_name[2])

                else:
                    pass

        elif object_name[1] == "active":
            current_texture = "*no-texture*"

            for line in lines:
                if line.startswith("v "):
                    line = line.removeprefix("v ")
                    line = line.split(" ")

                    x = str(float(line[0]) * 1)
                    y = str(float(line[1]) * 1)
                    z = str(float(line[2]) * -1)

                    vert_x.append(x)
                    vert_y.append(y)
                    vert_z.append(z)

                    floor_x.append(x)
                    floor_y.append(z)
                    floor_z.append(y)

                elif line.startswith("vn "):
                    pass

                elif line.startswith("vt "):
                    line = line.removeprefix("vt ")
                    line = line.split(" ")

                    u = line[0]
                    v = str(float(line[1]) * -1)

                    temp_u.append(u)
                    temp_v.append(v)

                elif line.startswith("s "):
                    pass

                elif line.startswith("usemtl "):
                    current_texture = line.removeprefix("usemtl ")

                elif line.startswith("f "):
                    line = line.removeprefix("f ")
                    line = line.split(" ")

                    p1 = line[0].split("/")[0]
                    p2 = line[1].split("/")[0]
                    p3 = line[2].split("/")[0]
                    pt1 = line[0].split("/")[1]
                    pt2 = line[1].split("/")[1]
                    pt3 = line[2].split("/")[1]
                    pn1 = line[0].split("/")[2]
                    pn2 = line[1].split("/")[2]
                    pn3 = line[2].split("/")[2]

                    active_p1.append(p1)
                    active_p2.append(p2)
                    active_p3.append(p3)

                    if current_texture == "*no-texture*":
                        active_u1.append(0)
                        active_v1.append(0)
                        active_u2.append(0)
                        active_v2.append(1)
                        active_u3.append(1)
                        active_v3.append(1)
                        active_texture_id.append("*no-texture*")

                    elif texture_type[texture_id.index(current_texture)] == "texture":
                        active_u1.append(float(temp_u[int(pt1) - 1]))
                        active_v1.append(1 - (0 - float(temp_v[int(pt1) - 1])))
                        active_u2.append(float(temp_u[int(pt2) - 1]))
                        active_v2.append(1 - (0 - float(temp_v[int(pt2) - 1])))
                        active_u3.append(float(temp_u[int(pt3) - 1]))
                        active_v3.append(1 - (0 - float(temp_v[int(pt3) - 1])))
                        active_texture_id.append(current_texture)

                    else:
                        active_u1.append(0)
                        active_v1.append(0)
                        active_u2.append(0)
                        active_v2.append(1)
                        active_u3.append(1)
                        active_v3.append(1)
                        active_texture_id.append(current_texture)

                    active_offset_x.append(object_name[2])
                    active_offset_y.append(object_name[4])
                    active_offset_z.append(object_name[3])
                    active_required.append(object_name[5])
                    active_ticks.append(object_name[6])
                    active_interpolation.append(object_name[7])
                    active_sound.append(object_name[8])

                else:
                    pass

        elif object_name[1] == "marker":
            final_marker_name = object_name[0]
            final_marker_x = 0
            final_marker_y = 0
            final_marker_z = 0
            final_marker_text = object_name[2].replace("_", " ")
            final_marker_locked_text = object_name[3].replace("_", " ")
            final_marker_sound = object_name[4].replace("_", " ")
            final_marker_required = object_name[5]

            for line in lines:
                if line.startswith("v "):
                    line = line.removeprefix("v ")
                    line = line.split(" ")

                    x = str(float(line[0]) * 1)
                    y = str(float(line[1]) * 1)
                    z = str(float(line[2]) * -1)

                    vert_x.append(x)
                    vert_y.append(y)
                    vert_z.append(z)

                    floor_x.append(x)
                    floor_y.append(z)
                    floor_z.append(y)

                    final_marker_x = x
                    final_marker_y = y
                    final_marker_z = z

                elif line.startswith("vt "):
                    line = line.removeprefix("vt ")
                    line = line.split(" ")

                    u = line[0]
                    v = str(float(line[1]) * -1)

                    temp_u.append(u)
                    temp_v.append(v)

                else:
                    pass

            marker_name.append(final_marker_name)
            marker_x.append(final_marker_x)
            marker_y.append(final_marker_y)
            marker_z.append(final_marker_z)
            marker_text.append(final_marker_text)
            marker_locked_text.append(final_marker_locked_text)
            marker_sound.append(final_marker_sound)
            marker_required.append(final_marker_required)

        elif object_name[1] == "bound":
            bound_x = []
            bound_y = []
            bound_z = []

            for line in lines:
                if line.startswith("v "):
                    line = line.removeprefix("v ")
                    line = line.split(" ")

                    x = str(float(line[0]) * 1)
                    y = str(float(line[1]) * 1)
                    z = str(float(line[2]) * -1)

                    vert_x.append(x)
                    vert_y.append(y)
                    vert_z.append(z)

                    floor_x.append(x)
                    floor_y.append(z)
                    floor_z.append(y)

                    bound_x.append(x)
                    bound_y.append(y)
                    bound_z.append(z)

                elif line.startswith("vt "):
                    line = line.removeprefix("vt ")
                    line = line.split(" ")

                    u = line[0]
                    v = str(float(line[1]) * -1)

                    temp_u.append(u)
                    temp_v.append(v)

                else:
                    pass

            bound_name.append(object_name[0])
            bound_x1.append(min(bound_x))
            bound_y1.append(min(bound_y))
            bound_z1.append(min(bound_z))
            bound_x2.append(max(bound_x))
            bound_y2.append(max(bound_y))
            bound_z2.append(max(bound_z))

        else:
            pass

    for i in range(len(floor_x)):
        for j in range(len(floor_x)):
            face_count = 0
            for k in range(len(floor_p1)):
                if are_vertices_in_face(str(i + 1), str(j + 1), str(floor_p1[k]), str(floor_p2[k]), str(floor_p3[k])):
                    face_count = face_count + 1
            if face_count == 1:  # if face_count == 1:
                floor_x1.append(floor_x[i])
                floor_y1.append(floor_y[i])
                floor_x2.append(floor_x[j])
                floor_y2.append(floor_y[j])

    global output
    output = ""

    def add(text):
        global output

        output = output + text + "\n"

    for i in range(len(texture_id)):
        add(f"t,{texture_id[i]},{texture_width[i]},{texture_height[i]},{texture_data[i]}")

    for i in range(len(vert_x)):
        add(f"v,{vert_x[i]},{vert_y[i]},{vert_z[i]}")

    for i in range(len(static_texture_id)):
        add(f"s,{static_p1[i]},{static_p2[i]},{static_p3[i]},{static_u1[i]},{static_v1[i]},{static_u2[i]},{static_v2[i]},{static_u3[i]},{static_v3[i]},{static_texture_id[i]},{static_bound[i]}")

    for i in range(len(active_texture_id)):
        add(f"a,{active_p1[i]},{active_p2[i]},{active_p3[i]},{active_u1[i]},{active_v1[i]},{active_u2[i]},{active_v2[i]},{active_u3[i]},{active_v3[i]},{active_texture_id[i]},{active_offset_x[i]},{active_offset_y[i]},{active_offset_z[i]},{active_required[i]},{active_ticks[i]},{active_interpolation[i]},{active_sound[i]}")

    for i in range(len(floor_x1)):
        add(f"c,{floor_x1[i]},{floor_y1[i]},{floor_x2[i]},{floor_y2[i]}")

    for i in range(len(marker_text)):
        add(f"m,{marker_name[i]},{marker_x[i]},{marker_y[i]},{marker_z[i]},{marker_text[i]},{marker_locked_text[i]},{marker_sound[i]},{marker_required[i]}")

    for i in range(len(bound_name)):
        add(f"b,{bound_name[i]},{bound_x1[i]},{bound_y1[i]},{bound_z1[i]},{bound_x2[i]},{bound_y2[i]},{bound_z2[i]}")

    for i in range(len(floor_p1)):
        add(f"f,{floor_p1[i]},{floor_p2[i]},{floor_p3[i]}")

    output = output.removesuffix("\n")

    return output


obj_directory = input("Enter directory for .obj file:\n")
obj_content = open(obj_directory, "r").read()
mtl_directory = find_text_after("mtllib ", obj_content)
mtl_content = open(mtl_directory, "r").read()
output_directory = "output.txt"

open(output_directory, "w").write(process(obj_content, mtl_content))
sun:
    type: static
    bound: none

launch_bound:
    type: bound

railway_bound:
    type: bound

start_off_bound:
    type: bound

floor:
    type: floor

start_off:
    type: static
    bound: start_off_bound

launchpad:
    type: static
    bound: launch_bound

launchpad_moon:
    type: static
    bound: none

observatory:
    type: static
    bound: start_off_bound

moon:
    type: static
    bound: none

railway:
    type: static
    bound: railway_bound

train:
    type: active
    bound: railway_bound
    x_offset: 0
    y_offset: -261
    z_offset: 0
    required: train_activate
    ticks: 600
    interpolation: smooth
    sound: train
    camera_lock: 1

train_activate:
    type: marker
    marker_type: active
    text: start train
    locked_text: train codes required
    sound: click
    required: train_codes

railway_door_open:
    type: marker
    marker_type: teleport
    text: enter railway area
    locked_text: train codes required
    sound: latch
    required: train_codes
    tpx: 20.7901
    tpy: -10.1468
    tpz: -0.205701


observatory_enter:
    type: marker
    marker_type: teleport
    text: enter observatory
    locked_text: locked
    sound: latch
    required: none
    tpx: 16.3412
    tpy: -4.91365
    tpz: 0.186427

observatory_exit:
    type: marker
    marker_type: teleport
    text: exit observatory
    locked_text: train codes required
    sound: latch
    required: train_codes
    tpx: 16.3157
    tpy: -9.17317
    tpz: 0.186427

train_codes:
    type: marker
    marker_type: active
    text: read train codes
    locked_text: none
    sound: paper
    required: none

launch_door_open:
    type: marker
    marker_type: teleport
    text: enter launch area
    locked_text: locked
    sound: latch
    required: none
    tpx: 18.2167
    tpy: -274.924
    tpz: 0.223597

keycard_take:
    type: marker
    marker_type: active
    text: take keycard
    locked_text: none
    sound: button
    required: none

keycard:
    type: active
    bound: none
    x_offset: 0
    y_offset: 0
    z_offset: -1
    required: keycard_take
    ticks: 1
    interpolation: linear
    sound: none
    camera_lock: 0

red_enter:
    type: marker
    marker_type: teleport
    text: enter
    locked_text: toxic gas detected~door locked
    sound: latch
    required: gas_vent
    tpx: 1.41255
    tpy: -8.72965
    tpz: 1.08007

gas_vent:
    type: marker
    marker_type: active
    text: vent toxic gas
    locked_text: keycard required
    sound: venting
    required: keycard_take

croissant:
    type: active
    bound: start_off_bound
    x_offset: 0
    y_offset: 0
    z_offset: -1
    required: croissant_eat
    ticks: 1
    interpolation: linear
    sound: none
    camera_lock: 0

croissant_eat:
    type: marker
    marker_type: active
    text: eat croissant
    locked_text: none
    sound: eat
    required: none

cryogenics_1a:
    type: marker
    marker_type: text
    text: cryogenics 1a
    locked_text: none
    required: none

cryogenics_1b:
    type: marker
    marker_type: text
    text: cryogenics 1b
    locked_text: none
    required: none

cryogenics_1c:
    type: marker
    marker_type: text
    text: cryogenics 1c
    locked_text: none
    required: none

cryogenics_2b:
    type: marker
    marker_type: text
    text: cryogenics 2b
    locked_text: none
    required: none

cryogenics_2c:
    type: marker
    marker_type: text
    text: cryogenics 2c
    locked_text: none
    required: none

cryogenics_3c:
    type: marker
    marker_type: text
    text: cryogenics 3c
    locked_text: none
    required: none

cryogenics_bulkhead_a3b3:
    type: marker
    marker_type: text
    text: explosion detected~bulkhead sealed
    locked_text: none
    required: none

atmosphere_control:
    type: marker
    marker_type: text
    text: atmosphere contorl
    locked_text: none
    required: none

toilet:
    type: marker
    marker_type: text
    text: toilet
    locked_text: none
    required: none

toilet_t1:
    type: marker
    marker_type: text
    text: toilet t1
    locked_text: none
    required: none

toilet_t2:
    type: marker
    marker_type: text
    text: toilet t2
    locked_text: none
    required: none

toilet_t3:
    type: marker
    marker_type: text
    text: toilet t3
    locked_text: none
    required: none

mess_hall_1:
    type: marker
    marker_type: text
    text: mess hall
    locked_text: none
    required: none

mess_hall_2:
    type: marker
    marker_type: text
    text: mess hall
    locked_text: none
    required: none

kitchen:
    type: marker
    marker_type: text
    text: kitchen
    locked_text: none
    required: none

office:
    type: marker
    marker_type: text
    text: office
    locked_text: none
    required: none

elevator:
    type: marker
    marker_type: text
    text: elevator~locked
    locked_text: none
    required: none

red_area:
    type: marker
    marker_type: text
    text: red area
    locked_text: none
    required: none

cryogenics_sound:
    type: sound
    sound: cryogenics
    range: 3.5
    volume: 50

observatory_sound:
    type: sound
    sound: observatory
    range: 3.5
    volume: 100

red_area_sound:
    type: sound
    sound: drips
    range: 5
    volume: 100

main_floor_enter:
    type: marker
    marker_type: teleport
    text: enter
    locked_text: locked
    sound: latch
    required: main_floor_door_unlock
    tpx: -5.90023
    tpy: 6.87366
    tpz: 1.3402

main_floor_door_unlock:
    type: marker
    marker_type: active
    text: unlock main floor
    locked_text: locked
    sound: button
    required: none

read_launch_codes:
    type: marker
    marker_type: active
    text: read launch codes
    locked_text: locked
    sound: paper
    required: none

authorize_launch:
    type: marker
    marker_type: active
    text: authorize ship launch
    locked_text: launch codes~required to~authorize ship~launch
    sound: activate
    required: read_launch_codes

ship_launch:
    type: marker
    marker_type: teleport
    text: launch
    locked_text: launch not authorized
    sound: button
    required: authorize_launch
    tpx: -40.3578
    tpy: -276.458
    tpz: 0.07108

ship:
    type: active
    bound: none
    x_offset: -47
    y_offset: -38
    z_offset: 69
    required: ship_launch
    ticks: 1200
    interpolation: cosine
    sound: launch
    camera_lock: 1

launch_observatory_sound:
    type: sound
    sound: observatory
    range: 3.5
    volume: 100
t,name,width,height,data
v,x,y,z
s,p1,p2,p3,u1,v1,u2,v2,u3,v3,texture,bounding box
a,p1,p2,p3,u1,v1,u2,v2,u3,v3,texture,bounding box,offset x,offset y,offset z,ticks,interpolation,sound,required
b,name,x1,y1,z1,x2,y2,z2
c,x1,y1,x2,y2
f,p1,p2,p3
m,name,active,x,y,z,text,locked text,sound,required
m,name,text,x,y,z,text
m,name,document,x,y,z,text,locked text,sound,required,document
m,name,teleport,x,y,z,text,locked text,sound,required,tpx,tpy,tpz
import random

# ===============================
# TCP: Trained Character Predictor
# ===============================
class TCP:
    # Shared system log for all TCP instances
    system_log = ["TCP (trained character predictor) AI class initialized"]

    def __init__(self, model_directory, search_start):
        """Load dataset and initialize search parameters."""
        with open(model_directory, "r") as f:
            self.model = f.read()  # Full text dataset
        self.search_start = search_start  # How far back in prompt to search

    def generate(self, prompt, response_length):
        """Generate a response character by character."""
        self.system_log.append("generating response")

        def next_character(prompt_):
            """Determine the next character based on the prompt."""
            self.system_log.append("finding next character")

            # Determine how much of the prompt to use for searching
            start = min(self.search_start, len(prompt_))

            # Helper: find all occurrences of `search_` in dataset
            def find_occurrences(dataset, search_):
                self.system_log.append("finding character occurrences")
                indexes = []
                idx = 0
                while True:
                    idx = dataset.find(search_, idx)
                    if idx == -1:
                        break
                    indexes.append(idx)
                    idx += 1
                return indexes

            # Try decreasing lengths of prompt for matching
            for i in range(-start, 1):
                self.system_log.append("finding prompt search length")
                options = []
                search = prompt_[i:]  # Current substring to search

                if search in self.model:
                    self.system_log.append("character found in dataset")
                    options = find_occurrences(self.model, search)

                    # Collect characters that follow the found substring
                    new_options = []
                    for pos in options:
                        try:
                            new_options.append(self.model[pos + len(search)])
                        except IndexError:
                            continue  # Skip if at end of dataset
                    options = new_options

                if options:
                    self.system_log.append("randomizing character selection")
                    return random.choice(options)
                else:
                    self.system_log.append("character not found")
                    self.system_log.append("decreasing prompt search length")

        # Generate response by repeatedly appending next characters
        for _ in range(response_length):
            prompt += next_character(prompt)

        self.system_log.append("ending prompt found")
        return prompt


# ===============================
# CCP: Cached Character Predictor
# ===============================
class CCP:
    def __init__(self, model_directory):
        """Load dataset and initialize cache."""
        with open(model_directory, "r") as f:
            self.model = f.read()  # Full text dataset
        self.system_log = ["CCP (cached character predictor) AI class initialized"]
        self.cache = {}  # Cache mapping each character to possible next chars

    def generate_cache(self):
        """
        Precompute a cache of characters for fast generation.
        Each character maps to a list of characters that follow it in the dataset.
        Uses wrap-around for the last character.
        """
        # Initialize empty lists for all unique characters
        self.cache = {c: [] for c in set(self.model)}

        # Fill cache by walking through dataset once
        for i, c in enumerate(self.model):
            next_char = self.model[(i + 1) % len(self.model)]  # wrap-around
            self.cache[c].append(next_char)

    def generate(self, prompt, response_length):
        """Generate a response using the precomputed cache."""
        self.system_log.append("generating response")

        def next_character(prompt_):
            """Return a random next character from the cache based on last prompt character."""
            self.system_log.append("finding next character")
            last_char = prompt_[-1]

            # Fallback in case last_char isn't in cache
            if last_char not in self.cache or not self.cache[last_char]:
                last_char = random.choice(list(self.cache.keys()))

            return random.choice(self.cache[last_char])

        # Generate the response character by character
        for _ in range(response_length):
            prompt += next_character(prompt)

        self.system_log.append("ending prompt found")
        return prompt


# ===============================
# Main execution
# ===============================
if __name__ == "__main__":
    # Initialize CCP with dataset file
    model = CCP("data.txt")
    print("Generating cache, please wait...")
    model.generate_cache()

    # Interactive loop
    while True:
        user_input = input("\nWhat can I help you with?\n")
        if user_input.lower() == "log":
            # Print system log for debugging
            for entry in model.system_log:
                print(entry)
        else:
            # Generate and print response
            print(model.generate(user_input, 1024))
package com.idtech;

import com.idtech.block.*;
import com.idtech.enchantment.EnchantmentMod;
import com.idtech.entity.*;
import com.idtech.item.*;

//import com.idtech.world.WorldMod;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.Tier;
import net.minecraft.world.item.Tiers;
import net.minecraft.world.item.enchantment.Enchantment;
import net.minecraft.world.level.biome.Biome;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraftforge.client.event.EntityRenderersEvent;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.TierSortingRegistry;
import net.minecraftforge.event.RegistryEvent;
import net.minecraftforge.event.entity.EntityAttributeCreationEvent;
import net.minecraftforge.event.server.ServerStartingEvent;
import net.minecraftforge.eventbus.api.EventPriority;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.InterModComms;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;
import net.minecraftforge.fml.event.lifecycle.InterModEnqueueEvent;
import net.minecraftforge.fml.event.lifecycle.InterModProcessEvent;
import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Collectors;

/**
 * The BaseMod class holds any static variables your mod needs and runs all registry events. You'll add registry lines
 * in this file for all of your block, item, entities, etc. that you add to Minecraft
 */
@Mod(BaseMod.MODID)
//@Mod.EventBusSubscriber(bus=Mod.EventBusSubscriber.Bus.MOD)
public class BaseMod {

    // Change your modid here. Whenever modid is needed, use BaseMod.MODID
    public static final String MODID = "examplemod";
    private static final Logger LOGGER = LogManager.getLogger(BaseMod.MODID);

    public BaseMod() {
        // Register the setup method for modloading
        FMLJavaModLoadingContext.get().getModEventBus().addListener(this::setup);
        // Register the enqueueIMC method for modloading
        FMLJavaModLoadingContext.get().getModEventBus().addListener(this::enqueueIMC);
        // Register the processIMC method for modloading
        FMLJavaModLoadingContext.get().getModEventBus().addListener(this::processIMC);

        // Register ourselves for server and other game events we are interested in
        MinecraftForge.EVENT_BUS.register(this);
    }

    /**
     * Setup step after all other registry events - if you need to do anything after everything else has loaded, put it here.
     *
     * @param event event info
     */
    public void setup(FMLCommonSetupEvent event) {
        // Do any mod setup steps here. Occurs after all registry events.
        // Put biome manager registry stuff here.
        BaseMod.LOGGER.info("Mod Setup Step");
//        WorldMod.setupBiomes();
       // TierSortingRegistry.registerTier(ItemMod.GEL_TIER, new ResourceLocation(MODID, "gelore"), List.of(Tiers.NETHERITE), List.of());

        BaseMod.LOGGER.info("Command registration here hopefully.");
//        MinecraftForge.EVENT_BUS.register(CustomEvent.class);
//        MinecraftForge.EVENT_BUS.addListener(EventMod::isHoldingEvent);
        //Adds the RegisterCommandEvent as an event and sets a listener for it during FMLCommonSetup
    }

    private void enqueueIMC(final InterModEnqueueEvent event) {
        // some example code to dispatch IMC to another mod
        InterModComms.sendTo(MODID, "helloworld", () -> {
            LOGGER.info("Hello world from the MDK");
            return "Hello world";
        });
    }

    private void processIMC(final InterModProcessEvent event) {
        // some example code to receive and process InterModComms from other mods
        LOGGER.info("Got IMC {}", event.getIMCStream().
                map(m -> m.messageSupplier().get()).
                collect(Collectors.toList()));
    }

        // You can use SubscribeEvent and let the Event Bus discover methods to call
    @SubscribeEvent
    public void onServerStarting(ServerStartingEvent event) {
        // do something when the server starts
        LOGGER.info("HELLO from server starting");
    }
    // You can use EventBusSubscriber to automatically subscribe events on the contained class (this is subscribing to the MOD
    // Event bus for receiving Registry Events)
    @Mod.EventBusSubscriber(bus=Mod.EventBusSubscriber.Bus.MOD)
    public static class RegistryEvents {
//        @SubscribeEvent
//        public static void onBlocksRegistry(final RegistryEvent.Register<Block> blockRegistryEvent) {
//            // register a new block here
//            LOGGER.info("HELLO from Register Block");
//        }

        /**
         * Registers block during mod setup
         *
         * @param event RegistryEvent to access the block registry
         */
        @SubscribeEvent
        public static void registerBlocks(final RegistryEvent.Register<Block> event) {
            LOGGER.info("Registering Blocks");


//            event.getRegistry().register(BlockMod.CASTLE_WALL);
            BlockMod.registerBlocks(event);

        }


        /**
         * Registers item during mod setup
         *
         * @param event RegistryEvent to access the item registry
         */
        @SubscribeEvent
        public static void registerItems(final RegistryEvent.Register<Item> event) {
            LOGGER.info("Registering Items");
            // Add item registry calls here.
            // event.getRegistry.register(<item variable>)

            ItemMod.registerItems(event);
            BlockMod.registerBlockItems(event);
            EntityMod.registerEntityEggs(event);

        }


        /**
         * Registers entities during mod setup
         *
         * @param event RegistryEvent to access the entity registry
         */
        @SubscribeEvent
        public static void registerEntities(final RegistryEvent.Register<EntityType<?>> event) {
            BaseMod.LOGGER.info("Registering Entities");
            // Add item registry calls here.
            // event.getRegistry.register(<entity type>)
            // also register the entity attributes with:
            // GlobalEntityTypeAttributes.put(<entity type>, <entity attribute method>.func_233813_a_());
            EntityMod.registerEntities(event);

        }

        @SubscribeEvent
        public static void registerBiomes(final RegistryEvent.Register<Biome> event) {
            BaseMod.LOGGER.info("Registering Biomes");
            // Add biome registry calls here
            // event.getRegistry.register(<biome variable>)
//            WorldMod.registerBiomes(event);

        }

        @SubscribeEvent
        public static void entityRenderers(final EntityRenderersEvent.RegisterRenderers event){
            EntityMod.entityRenderers(event);
        }
        @SubscribeEvent
        public static void attributeRegister(EntityAttributeCreationEvent event) {
            EntityMod.onAttributeCreate(event);
        }

        @SubscribeEvent
        public static void registerEnchantments(final RegistryEvent.Register<Enchantment> event){
            EnchantmentMod.registerEnchantments(event);
        }

    }
}


package com.idtech;

import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LightningBolt;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.ClipContext;
import net.minecraft.world.level.Explosion;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.WorldGenLevel;
import net.minecraft.world.level.block.BaseFireBlock;
import net.minecraft.world.level.block.CampfireBlock;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraft.world.phys.HitResult;
import net.minecraft.world.phys.Vec3;

import javax.sound.sampled.Clip;

/**
 * Utilities to use with block, item and entities to simplify some functionality
 */
public class Utils {

    /**
     * Strikes a location with lightning
     * @param world The world to strike lightning in
     * @param location The block position to strike with lightning
     */
    public static void strikeLightning(Level world, BlockPos location){

//        if (world instanceof ServerWorld){
//            ServerWorld serverWorld = (ServerWorld) world;
            LightningBolt lightningBolt = new LightningBolt(EntityType.LIGHTNING_BOLT, world);
            lightningBolt.setPos(location.getX(), location.getY(), location.getZ());
            world.addFreshEntity(lightningBolt);


    }

    /**
     * Creates an explosion at location with radius of explosionRadius
     * @param level The world to create explosion in
     * @param location the block position to create explosion
     * @param explosionRadius the radius of the explosion
     */
    public static void createExplosion(Level level, BlockPos location, float explosionRadius){
        level.explode(null, location.getX(), location.getY(), location.getZ(), explosionRadius, Explosion.BlockInteraction.BREAK);
       // level.explode()
    }

    /**
     * Method to spawn an entity into the world. Use after creating an Entity object to add as a parameter for this method.
     * e.g: Cow cow = new Cow();
     *      spwanEntity(level, cow, location);
     * @param level the world in which we are spawning
     * @param entity an entity object that will be spawned
     * @param location the location in which the entity should be spawned.
     * @return the entity that has been spawned
     */
    public static Entity spawnEntity(Level level, Entity entity, BlockPos location){

        entity.setPos(location.getX(), location.getY(), location.getZ());
        level.addFreshEntity(entity);

        return entity;
    }

    /**
     * Get the block that the player is looking at.
     * @param player The player whose look we're checking
     * @param distance range to check in block
     * @return Block position if one is found within range, null if no block in range.
     */

    public static BlockPos getBlockAtCursor(Player player, double distance, boolean ignoreFluids) {
        ClipContext.Fluid fluidMode = ignoreFluids ? ClipContext.Fluid.NONE : ClipContext.Fluid.ANY;

        ClipContext rayTraceContext = new ClipContext(player.getEyePosition(1), player.getEyePosition(1).add(player.getLookAngle().scale(distance)), ClipContext.Block.COLLIDER, fluidMode, player);
        BlockHitResult blockHit = player.level.clip(rayTraceContext);

        if(blockHit.getType() == BlockHitResult.Type.MISS){
            return null;
        }
        else {
            return blockHit.getBlockPos();
        }

    }



    /**
     * Set a block location on fire.
     * @param world world to set the fire in.
     * @param location The block location to set on fire.
     * @param face The side of the block to set on fire. Use Direction.UP, DOWN, NORTH, SOUTH, EAST, WEST
     */

    public static void setFireBlock(Level world, BlockPos location, Direction face){
        BlockState blockState = world.getBlockState(location);

        if (CampfireBlock.canLight(blockState)) {
            world.playSound(null, location, SoundEvents.FLINTANDSTEEL_USE, SoundSource.BLOCKS, 1.0F, world.getRandom().nextFloat() * 0.4F + 0.8F);
            world.setBlock(location, blockState.setValue(BlockStateProperties.LIT, Boolean.valueOf(true)), 11);
        } else {
           // BlockPos blockpos1 = location.offset(face);
            if (BaseFireBlock.canBePlacedAt(world, location, face)) {
                world.playSound(null, location, SoundEvents.FLINTANDSTEEL_USE, SoundSource.BLOCKS,  1.0F, world.getRandom().nextFloat() * 0.4F + 0.8F);
                BlockState blockstate1 = BaseFireBlock.getState(world, location);
                world.setBlock(location, blockstate1, 11);

            }
        }
    }

    /**
     * Find a random block pos based on a block pos.
     * @param pos position of the block from which to spread
     * @return a random position near that block.
     */
    public static BlockPos findNeightborBlock(BlockPos pos){

        int spreadX = (int)Math.floor(Math.random()*3) - 1;
        int spreadY = spreadX == 0 ? (int)Math.floor(Math.random()*3) - 1 : 0 ;
        int spreadZ = spreadX == 0  && spreadY == 0 ? (int)Math.floor(Math.random()*3) - 1 : 0;
        //changed to offset from add
        BlockPos spreadPos = pos.offset(spreadX, spreadY, spreadZ);

        return spreadPos;
    }

}
package com.idtech;

import com.idtech.item.LightSword;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.ItemStack;

public class ModStuff extends CreativeModeTab {

    public static CreativeModeTab INSTANCE = new ModStuff("examplemod");

    public ModStuff(String label) { super(label); }

    @Override
    public ItemStack makeIcon() { return new ItemStack(LightSword.INSTANCE); }
}
package com.idtech.block;


import com.idtech.ModStuff;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraft.world.level.block.Block;
//import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.material.Material;
//import net.minecraftforge.common.ToolType;
import net.minecraftforge.event.RegistryEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

@Mod.EventBusSubscriber
public class BlockMod {

    //Basic Block
    public static final Block CASTLE_WALL = BlockUtils.createBasicBlock("castlewall", Material.STONE);
    public static final Item CASTLE_WALL_ITEM = BlockUtils.createBlockItem(CASTLE_WALL, ModStuff.INSTANCE);

    public static final Block LOGO = BlockUtils.createBasicBlock("logo", Material.STONE);
    public static final Item LOGO_ITEM = BlockUtils.createBlockItem(LOGO, ModStuff.INSTANCE);

    public static final Block CONVEYOR_BELT = BlockUtils.createBasicBlock("conveyorbelt", Material.STONE);
    public static final Item CONVEYOR_BELT_ITEM = BlockUtils.createBlockItem(CONVEYOR_BELT, ModStuff.INSTANCE);


    @SubscribeEvent
    public static void registerBlockItems(RegistryEvent.Register<Item> event) {

        event.getRegistry().register(CASTLE_WALL_ITEM);

        event.getRegistry().register(LOGO_ITEM);

        event.getRegistry().register(CONVEYOR_BELT_ITEM);



    }

    @SubscribeEvent
    public static void registerBlocks(RegistryEvent.Register<Block> event) {

        event.getRegistry().register(CASTLE_WALL);

        event.getRegistry().register(LOGO);

        event.getRegistry().register(CONVEYOR_BELT);


    }
}





package com.idtech.block;

import com.idtech.BaseMod;
import net.minecraft.core.Registry;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.BlockItem;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.material.Material;

/**
 * Utilities specific to creating block and doing things with block.
 */
public class BlockUtils {

    /**
     * If you need a basic block with no extra functionality, you can use this function to create one.
     * @param name the name of the block. Must be all lowercase and contain no spaces.
     * @param material the block's material
     * @return the constructe block with parameters
     */

    public static Block createBasicBlock(String name, Material material){
        return new Block(Block.Properties.of(material)).setRegistryName(BaseMod.MODID, name);
    }

    public static Block createBasicBlock(String name, Material material, float strength){
        return new Block(Block.Properties.of(material).strength(strength)).setRegistryName(BaseMod.MODID, name);
    }


    /**
     * Create a block item so that players can hold the block in their inventory.
     * @param block The block to create an item of
     * @param group The item group (creative tab) the block should go into.
     * @return The constructed block item
     */
    public static Item createBlockItem(Block block, CreativeModeTab group){
        return new BlockItem(block, new Item.Properties().tab(group)).setRegistryName(block.getRegistryName());
    }
}
package com.idtech.enchantment;

import net.minecraft.world.item.enchantment.Enchantment;
import net.minecraftforge.event.RegistryEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;

public class EnchantmentMod {

    public static void registerEnchantments(RegistryEvent.Register<Enchantment> event) {

    }

}
package com.idtech.entity;

import net.minecraft.world.entity.EntityType;
import net.minecraft.world.item.Item;
import net.minecraftforge.client.event.EntityRenderersEvent;
import net.minecraftforge.event.RegistryEvent;
import net.minecraftforge.event.entity.EntityAttributeCreationEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;

public class EntityMod {

    @SubscribeEvent
    public static void registerEntities(final RegistryEvent.Register<EntityType<?>> event){

    }
    @SubscribeEvent
    public static void registerEntityEggs(final RegistryEvent.Register<Item> event) {

    }
    @SubscribeEvent
    public static void entityRenderers(final EntityRenderersEvent.RegisterRenderers event){

    }

    // this is different than in 1.16 but everything else is the same
    // I do think this makes more sense than the other way but alas change is usually hard.
    @SubscribeEvent
    public static void onAttributeCreate(EntityAttributeCreationEvent event) {

    }

}
package com.idtech.entity;

import net.minecraft.world.entity.EntityType;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.SpawnEggItem;

public class EntityUtils {


    /**
     *  Returns a spawn egg item
     * @param type
     * @param primaryColor
     * @param secondaryColor
     * @return the spawn egg item with name and colors set.
     */
    public static Item buildEntitySpawnEgg(EntityType type, int primaryColor, int secondaryColor){
        return new SpawnEggItem(type, primaryColor, secondaryColor, new Item.Properties().tab(CreativeModeTab.TAB_MISC)).setRegistryName(type.getRegistryName() + "_egg");
    }


}
package com.idtech.item;

import com.idtech.ModStuff;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraftforge.event.RegistryEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

@Mod.EventBusSubscriber
public class ItemMod {

    //BASIC ITEMS
    public static final Item STRUCTURE_GEL = ItemUtils.buildBasicItem("structuregel", ModStuff.INSTANCE);

    public static final Item PHONE = ItemUtils.buildBasicItem("phone", ModStuff.INSTANCE);

    //FOODS


    @SubscribeEvent
    public static void registerItems(RegistryEvent.Register<Item> event) {

        //BASIC ITEMS
        event.getRegistry().register(STRUCTURE_GEL);

        event.getRegistry().register(PHONE);

        // ITEMS
        event.getRegistry().register(LightSword.INSTANCE);

        // TOOLS

        // FOOD

        // ARMOR

        //PROJECTILES

    }
}
package com.idtech.item;

import com.idtech.BaseMod;

import net.minecraft.core.Registry;
import net.minecraft.resources.ResourceLocation;

import net.minecraft.tags.Tag;
import net.minecraft.util.LazyLoadedValue;
import net.minecraft.world.entity.EquipmentSlot;
import net.minecraft.world.food.FoodProperties;
import net.minecraft.world.item.ArmorMaterial;
import net.minecraft.world.item.BlockItem;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.level.block.Block;
import net.minecraft.sounds.SoundEvent;
import net.minecraftforge.registries.ForgeRegistries;

import java.util.Optional;
import java.util.function.Supplier;

/**
 * Utilities for creating new item and doing things with item
 */
public class ItemUtils {

    /**
     * Build a basic item with no added functionality. Useful for crafting materials, drops, ingots, currency, anything
     * that doesn't need extra code.
     * @param name Item registry name. All lowercase, no spaces. e.g. "meteor_ingot"
     * @param group Item group (creative tab) the item will appear in.
     * @return The built item.
     */
    public static Item buildBasicItem(String name, CreativeModeTab group){
        return new Item(new Item.Properties().tab(group)).setRegistryName(BaseMod.MODID, name);
    }

    /**
     * Create a new food item to register a food and have it appear in the game
     * @param name the name of the food item for registry and textures
     * @param food the food item itself.
     * @return
     */
    public static Item buildFoodItem(String name, FoodProperties food){
        return new Item(new Item.Properties().tab(CreativeModeTab.TAB_FOOD).food(food)).setRegistryName(BaseMod.MODID, name);
    }


    /**
     *  Create a new armor material. Used for new armor sets that use custom materials.
     * @param nameIn the name of the material, can be whatever.
     * @param maxDamageFactorIn Multiplier for durability.
     * @param damageReductionAmountArrayIn Defense points for each armor slot.
     * @param enchantabilityIn Enchantability of armor with the item.
     * @param eqiupSoundIn Sound for equipping the armor.
     * @param toughnessIn How long it takes until the armor breaks.
     * @param knockbackResistanceIn A value for knockback resistance of the armor.
     * @param repairIngredientName A registry name of the ingredient needed to repair this tool e.g. "minecraft:stick"
     *      *                       or "examplemod:meteor_ingot".
     * @return the built Armor Material
     */
    public static ArmorMaterial buildArmorMaterial(String nameIn, int maxDamageFactorIn, int[] damageReductionAmountArrayIn, int enchantabilityIn, SoundEvent eqiupSoundIn,
                                                    float toughnessIn, float knockbackResistanceIn, String repairIngredientName){
        Supplier<Ingredient> ingredientSupplier = ()-> Ingredient.of(ForgeRegistries.ITEMS.getValue(new ResourceLocation(repairIngredientName)));
        return buildArmorMaterial(nameIn, maxDamageFactorIn, damageReductionAmountArrayIn, enchantabilityIn, eqiupSoundIn, toughnessIn, knockbackResistanceIn, ingredientSupplier);

    }

    /**
     *  Alternate method to create an armor material that uses Item Tags instead of a single repair ingredient.
     *  Create a new armor material. Used for new armor sets that use custom materials.
     * @param nameIn the name of the material, can be whatever.
     * @param maxDamageFactorIn Multiplier for durability.
     * @param damageReductionAmountArrayIn Defense points for each armor slot.
     * @param enchantabilityIn Enchantability of armor with the item.
     * @param eqiupSoundIn Sound for equipping the armor.
     * @param toughnessIn How long it takes until the armor breaks.
     * @param knockbackResistanceIn A value for knockback resistance of the armor.
     * @param itemTag an Item Tag indicating a group or type of item that can repair this armor material.
     * @return the built Armor Material
     */
    public static ArmorMaterial buildArmorMaterial(String nameIn, int maxDamageFactorIn, int[] damageReductionAmountArrayIn, int enchantabilityIn, SoundEvent eqiupSoundIn,
                                                   float toughnessIn, float knockbackResistanceIn, Tag<Item> itemTag){
        Supplier<Ingredient> ingredientSupplier = () -> Ingredient.of(itemTag);
        return buildArmorMaterial(nameIn, maxDamageFactorIn, damageReductionAmountArrayIn, enchantabilityIn, eqiupSoundIn, toughnessIn, knockbackResistanceIn, ingredientSupplier);

    }

    /**
     * Builds a new custom armor material. Modelled exactly after Vanilla Mincraft armor material code.
     * @param nameIn name of the material
     * @param maxDamageFactorIn the maximum damage for the armor
     * @param damageReductionAmountArrayIn the damage reduction that each piece of armor does in an array. In order helm, chest, legs, boots.
     * @param enchantabilityIn the enchantability factor of the armor.
     * @param eqiupSoundIn the sound that the armor makes when being equipped
     * @param toughnessIn any additional toughness of the armor
     * @param knockbackResistanceIn additional knockback resistance in the armor
     * @param repairIngredientIn ingredient used to repair the armor.
     * @return
     */
    private static ArmorMaterial buildArmorMaterial(String nameIn, int maxDamageFactorIn, int[] damageReductionAmountArrayIn, int enchantabilityIn, SoundEvent eqiupSoundIn,
                                                     float toughnessIn, float knockbackResistanceIn, Supplier<Ingredient> repairIngredientIn) {

        final int[] MAX_DAMAGE_ARRAY = new int[]{13, 15, 16, 11};

        return new ArmorMaterial() {

            final String name = nameIn;
            final int maxDamageFactor = maxDamageFactorIn;
            final int[] damageReductionAmountArray = damageReductionAmountArrayIn;
            final int enchantability = enchantabilityIn;
            final SoundEvent soundEvent = eqiupSoundIn;
            final float toughness = toughnessIn;
            final float knockbackResistance = knockbackResistanceIn;
            final LazyLoadedValue<Ingredient>  repairMaterial = new LazyLoadedValue<>(repairIngredientIn);
            ;


        public int getDurabilityForSlot(EquipmentSlot slotIn){
            return MAX_DAMAGE_ARRAY[slotIn.getIndex()] * this.maxDamageFactor;
        }
        public int getDefenseForSlot(EquipmentSlot slotIn) {
                return this.damageReductionAmountArray[slotIn.getIndex()];
        }

        public int getEnchantmentValue () {
            return this.enchantability;
        }

        public SoundEvent getEquipSound() {
            return this.soundEvent;
        }
        @Override
        public Ingredient getRepairIngredient () {
            return this.repairMaterial.get();
        }

        @Override
        public String getName () {
            return this.name;
        }
        @Override
        public float getToughness () {
            return this.toughness;
        }
        @Override
        public float getKnockbackResistance() {
            return this.knockbackResistance;
        }
    };

    }


}
package com.idtech.item;

import com.idtech.ModStuff;
import net.minecraft.world.item.*;

public class LightSword extends SwordItem {
    private static Properties properties = new Properties().tab(ModStuff.INSTANCE);
    public static Item INSTANCE = new LightSword(Tiers.NETHERITE, 200, 200, properties).setRegistryName("lightsword");
    public LightSword(Tier tier, int speed, float damage, Properties properties) {
        super(tier, speed, damage, properties);
    }
}
++++++++++[>+>+++<<-]>--.>>.>.<<<<...>>>++.>+.+++++..+++++.>++++.---------.<+[[-]+]<>[[>+>+<<-]>]<<-[----->++<---]<.[->[-----]>[>[>+>+<<-]>]]><[->++++++++++++++]<[---------------------------]->[>+++[++[------]]]>[[[>],[+[>>>+<<<<-]>]]]>>.>.<<<<...>>>++.>+.+++++..+++++.>++++.---------.<+[[-]+]<>[[>+>+<<-]>]<<-[----->++<---]<.[->[-----]>[>[>+>+<<-]>]]><[->++++++++++++++]<[---------------------------]->[>+++[++[------]]]>[[[>],[+[>>>+<<<<-]>]]]